{{- if .Values.alloy.logs.enabled }}
apiVersion: v1
kind: ConfigMap
metadata:
  name: utils
  namespace: {{ .Release.Namespace }}
data:
  utils: |   
    declare "default_level" {
      argument "forward_to" {
        comment = "Must be a list(LogsReceiver) where collected logs should be forwarded to"
      }

      argument "default_level" {
        comment = "The default log level to use if one is not set (default: unknown)"
        optional = true
        default = "unknown"
      }

      export "receiver" {
        value = loki.process.level_default.receiver
      }

      loki.process "level_default" {
        forward_to = argument.forward_to.value

        /*******************************************************************************
        *                         Log-Level Parsing
        ********************************************************************************/
        // default level to unknown
        stage.static_labels {
          values = {
            level = argument.default_level.value,
          }
        }

        // default level to unknown
        stage.static_labels {
          values = {
            log_type = "unknown",
          }
        }

        // check to see if the log line matches the klog format (https://github.com/kubernetes/klog)
        stage.match {
          // unescaped regex: ([IWED][0-9]{4}\s+[0-9]{2}:[0-9]{2}:[0-9]{2}\.[0-9]+)
          selector = "{level=\"" + argument.default_level.value + "\"} |~ \"([IWED][0-9]{4}\\\\s+[0-9]{2}:[0-9]{2}:[0-9]{2}\\\\.[0-9]+)\""

          // extract log level, klog uses a single letter code for the level followed by the month and day i.e. I0119
          stage.regex {
            expression = "((?P<level>[A-Z])[0-9])"
          }

          // if the extracted level is I set INFO
          stage.replace {
            source = "level"
            expression = "(I)"
            replace = "INFO"
          }

          // if the extracted level is W set WARN
          stage.replace {
            source = "level"
            expression = "(W)"
            replace = "WARN"
          }

          // if the extracted level is E set ERROR
          stage.replace {
            source = "level"
            expression = "(E)"
            replace = "ERROR"
          }

          // if the extracted level is I set INFO
          stage.replace {
            source = "level"
            expression = "(D)"
            replace = "DEBUG"
          }

          // set the log_type
          stage.static_labels{
            values = {
              log_type = "klog",
            }
          }

          // set the extracted level to be a label
          stage.labels {
            values = {
              level = "",
            }
          }
        }

        // check to see if the log line matches the zerolog format
        stage.match {
          // unescaped regex: ^.+(TRC|DBG|INF|WRN|ERR|FTL|PNC)[^=]+(\w+=("[^"]*"|\S+))(\s+(\w+=("[^"]*"|\S+)))*\s*$
          selector = "{level=\"" +  argument.default_level.value + "\"} |~ \"^.+(TRC|DBG|INF|WRN|ERR|FTL|PNC)[^=]+(\\\\w+=(\\\"[^\\\"]*\\\"|\\\\S+))(\\\\s+(\\\\w+=(\\\"[^\\\"]*\\\"|\\\\S+)))*\\\\s*$\""

          // set the log_type
          stage.static_labels{
            values = {
              log_type = "zerolog",
            }
          }

          // extract the level from the log
          // unescaped regex: (?P<timestamp>[0-9]{4}-[0-9]{2}-[0-9]{2}(T|\s+)[0-9]{2}:[0-9]{2}:[0-9]{2}.[0-9]+[^ ]*\s+)(?P<level>(TRC|DBG|INF|WRN|ERR|FTL|PNC)).+
          stage.regex {
            expression = "(?P<timestamp>[0-9]{4}-[0-9]{2}-[0-9]{2}(T|\\s+)[0-9]{2}:[0-9]{2}:[0-9]{2}.[0-9]+[^ ]*\\s+)(?P<level>(TRC|DBG|INF|WRN|ERR|FTL|PNC)).+"
          }

          // set the extracted level to be a label
          stage.labels {
            values = {
              level = "",
            }
          }
        }

        // if the level is still unknown, do one last attempt at detecting it based on common levels
        stage.match {
          selector = "{level=\"" + argument.default_level.value + "\"}"

          // unescaped regex: (?i)(?:"(?:level|loglevel|levelname|lvl|levelText|SeverityText)":\s*"|\s*(?:level|loglevel|levelText|lvl)="?|\s+\[?)(?P<level>(DEBUG?|DBG|INFO?(RMATION)?|WA?RN(ING)?|ERR(OR)?|CRI?T(ICAL)?|FATAL|FTL|NOTICE|TRACE|TRC|PANIC|PNC|ALERT|EMERGENCY))("|\s+|-|\s*\])
          stage.regex {
            expression = "(?i)(?:\"(?:level|loglevel|levelname|lvl|levelText|SeverityText)\":\\s*\"|\\s*(?:level|loglevel|levelText|lvl)=\"?|\\s+\\[?)(?P<level>(DEBUG?|DBG|INFO?(RMATION)?|WA?RN(ING)?|ERR(OR)?|CRI?T(ICAL)?|FATAL|FTL|NOTICE|TRACE|TRC|PANIC|PNC|ALERT|EMERGENCY))(\"|\\s+|-|\\s*\\])"
          }

          // set the extracted level to be a label
          stage.labels {
            values = {
              level = "",
            }
          }
        }
      }
    }

    declare "normalize_level" {
      argument "forward_to" {
        comment = "Must be a list(LogsReceiver) where collected logs should be forwarded to"
      }

      argument "transform" {
        comment = "The transformation to apply to the level can be 'ToLower' or 'ToUpper' (default: ToLower)"
        optional = true
        default = "ToLower"
      }

      export "receiver" {
        value = loki.process.level_normalize.receiver
      }

      loki.process "level_normalize" {
        forward_to = argument.forward_to.value

        /*******************************************************************************
        *                         Log-Level Normalization
        ********************************************************************************/
        // normalize debug level, handles TRC, TRAC, or TRACE
        stage.replace {
          source = "level"
          expression = "(?i)(trace?|trc)\\d*"
          replace = "trace"
        }

        // normalize debug level, handles DBG, DEBU, DEBUG, DEBUG1, DEBUG2, DEBUG3, DEBUG4, DEBUG5, etc.
        stage.replace {
          source = "level"
          expression = "(?i)(debug?|dbg)\\d*"
          replace = "debug"
        }

        // normalize info level handles INF, INFO, INFORMATION, or INFORMATIONAL
        stage.replace {
          source = "level"
          expression = "(?i)(info?(mation(al)?)?)"
          replace = "info"
        }

        // normalize the warning level handles WRN, WARN or WARNING
        stage.replace {
          source = "level"
          expression = "(?i)(wa?rn(ing)?)"
          replace = "warning"
        }

        // normalize the error level handles ERR or ERROR
        stage.replace {
          source = "level"
          expression = "(?i)(err(or)?)"
          replace = "error"
        }

        // normalize the fatal level handles FTL or FATAL
        stage.replace {
          source = "level"
          expression = "(?i)(fatal|ftl)"
          replace = "fatal"
        }

        // normalize the critical level handles CRIT or CRITICAL
        stage.replace {
          source = "level"
          expression = "(?i)(crit(ical)?)"
          replace = "critical"
        }

        // normalize the panic level handles PNC or PANIC
        stage.replace {
          source = "level"
          expression = "(?i)(panic|pnc)"
          replace = "critical"
        }

        // the level value could be anything fatal, notice, alert, emergency, there are no combinations / abbreviations to normalize for these
        // but we can still convert to lower or upper case
        stage.template {
          source = "level"
          template = "{{ " + argument.transform.value + " .Value }}"
        }

        // set the extracted level to be a label
        stage.labels {
          values = {
            level = "",
          }
        }
      }
    }

    declare "pre_process_metrics" {
      argument "keep_labels" {
        optional = true
        comment = "List of labels to keep before the metrics are generated"
        default = [
          "app",
          "cluster",
          "component",
          "env",
          "level",
          "namespace",
          "region",
          "service",
          "squad",
          "team",
          "workload",
        ]
      }

      argument "prefix" {
        comment = "the suffix to use with the metric names (default: log_)"
        optional = true
        default = "log_"
      }

      argument "suffix" {
        comment = "the suffix to use with the metric names (default: _pre_total)"
        optional = true
        default = "_pre_total"
      }

      export "receiver" {
        value = loki.process.pre_process_metrics.receiver
      }

      loki.process "pre_process_metrics" {
        forward_to = []

        stage.label_keep {
          values = argument.keep_labels.value
        }

        stage.metrics {
          metric.counter {
            name = "lines" + argument.suffix.value
            description = "total number of log lines ingested before processing"
            prefix = argument.prefix.value
            match_all = true
            action = "inc"
            max_idle_duration = "24h"
          }
        }

        stage.metrics {
            metric.counter {
              name = "bytes" + argument.suffix.value
            description = "total number of log bytes ingested before processing"
              prefix = argument.prefix.value
              match_all = true
              count_entry_bytes = true
              action = "add"
              max_idle_duration = "24h"
            }
        }
      }
    }

    declare "post_process_metrics" {
      argument "keep_labels" {
        optional = true
        comment = "List of labels to keep before the metrics are generated"
        default = [
          "app",
          "cluster",
          "component",
          "env",
          "level",
          "namespace",
          "region",
          "service",
          "squad",
          "team",
          "workload",
        ]
      }

      argument "prefix" {
        comment = "the suffix to use with the metric names (default: log_)"
        optional = true
        default = "log_"
      }

      argument "suffix" {
        comment = "the suffix to use with the metric names (default: _total)"
        optional = true
        default = "_total"
      }

      export "receiver" {
        value = loki.process.post_process_metrics.receiver
      }

      loki.process "post_process_metrics" {
        forward_to = []

        stage.metrics {
          metric.counter {
            name = "lines" + argument.suffix.value
            description = "total number of log lines ingested before processing"
            prefix = argument.prefix.value
            match_all = true
            action = "inc"
            max_idle_duration = "24h"
          }
        }

        stage.metrics {
            metric.counter {
              name = "bytes" + argument.suffix.value
            description = "total number of log bytes ingested before processing"
              prefix = argument.prefix.value
              match_all = true
              count_entry_bytes = true
              action = "add"
              max_idle_duration = "24h"
            }
        }
      }
    }

    declare "structured_metadata" {
      argument "forward_to" {
        comment = "Must be a list(LogsReceiver) where collected logs should be forwarded to"
      }

      argument "metadata" {
        optional = true
      }

      export "receiver" {
        value = loki.process.structured_metadata.receiver
      }

      /*
      As all of the pod labels and annotations we transformed into labels in the previous relabelings to make
      them available to the pipeline processing we need to ensure they are not automatically created in Loki.
      This would result in an extremely high number of labels and values severely impacting query performance.
      Not every log has to contain these labels, but this list should reflect the set of labels that you want
      to explicitly allow.
      */
      loki.process "structured_metadata" {
        forward_to = argument.forward_to.value

        stage.structured_metadata {
          values = coalesce(argument.metadata.value, {
            filename = "filename",
            instance = "instance",
            log_type = "log_type",
            version = "version",
            helm_chart = "helm_sh_chart",
            pod = "pod",
          })
        }

      }
    }

    declare "keep_labels" {
      argument "forward_to" {
        comment = "Must be a list(LogsReceiver) where collected logs should be forwarded to"
      }

      argument "keep_labels" {
        optional = true
        comment = "List of labels to keep before the log message is written to Loki"
        default = [
          "app",
          "cluster",
          "component",
          "container",
          "env",
          "job",
          "level",
          "namespace",
          "region",
          "service",
          "squad",
          "team",
          "workload",
        ]
      }

      export "receiver" {
        value = loki.process.keep_labels.receiver
      }

      /*
      As all of the pod labels and annotations we transformed into labels in the previous relabelings to make
      them available to the pipeline processing we need to ensure they are not automatically created in Loki.
      This would result in an extremely high number of labels and values severely impacting query performance.
      Not every log has to contain these labels, but this list should reflect the set of labels that you want
      to explicitly allow.
      */
      loki.process "keep_labels" {
        forward_to = argument.forward_to.value

        stage.label_keep {
          values = argument.keep_labels.value
        }

      }
    }
{{- end }}
