{{- if .Values.alloy.logs.enabled }}
apiVersion: v1
kind: ConfigMap
metadata:
  name: annotations
  namespace: {{ .Release.Namespace }}
data:
  annotations: |
    declare "drop_levels" {
      argument "forward_to" {
        comment = "Must be a list(LogsReceiver) where collected logs should be forwarded to"
      }

      argument "annotation" {
        comment = "The annotation namespace to use (default: logs.grafana.com)"
        default = "logs.grafana.com"
        optional = true
      }

      argument "trace_value" {
        comment = "The regular expression to use to determine if trace logs should be dropped, if you want to drop trace by default without setting the annotations everywhere use '.*' or 'true|' (default: true)"
        default = "true"
        optional = true
      }

      argument "trace_level" {
        comment = "The regular expression to use to match trace logs level label value (default: (?i)(trace?|trc))"
        default = "(?i)(trace?|trc)"
        optional = true
      }

      argument "debug_value" {
        comment = "The regular expression to use to determine if debug logs should be dropped, if you want to drop debug by default without setting the annotations everywhere use '.*' or 'true|' (default: true)"
        default = "true"
        optional = true
      }

      argument "debug_level" {
        comment = "The regular expression to use to match debug logs level label value (default: (?i)(debug?|dbg))"
        default = "(?i)(debug?|dbg)"
        optional = true
      }

      argument "info_value" {
        comment = "The regular expression to use to determine if info logs should be dropped, if you want to drop info by default without setting the annotations everywhere use '.*' or 'true|' (default: true)"
        default = "true"
        optional = true
      }

      argument "info_level" {
        comment = "The regular expression to use to match info logs level label value (default: (?i)(info?))"
        default = "(?i)(info?)"
        optional = true
      }

      argument "__sd_annotation" {
        optional = true
        comment = "The logic is used to transform the annotation argument into a valid label name by removing unsupported characters."
        default = replace(replace(replace(coalesce(argument.annotation.value, "logs.grafana.com"),".", "_"),"/", "_"),"-", "_")
      }

      export "annotation" {
        value = argument.annotation.value
      }

      export "receiver" {
        value = loki.process.drop_level.receiver
      }

      loki.process "drop_level" {
        forward_to = argument.forward_to.value

        stage.match {
          pipeline_name = "pipeline for annotation ||" + argument.annotation.value + "/drop-trace: true"
          selector = "{" + argument.__sd_annotation.value + "_drop_trace=~\"" + argument.trace_value.value + "\"" + ",level=~\"" + argument.trace_level.value + "\"}"
          action = "drop"
          drop_counter_reason = "trace"
        }

        stage.match {
          pipeline_name = "pipeline for annotation ||" + argument.annotation.value + "/drop-debug: true"
          selector = "{" + argument.__sd_annotation.value + "_drop_debug=~\"" + argument.debug_value.value + "\"" + ",level=~\"" + argument.debug_level.value + "\"}"
          action = "drop"
          drop_counter_reason = "debug"
        }

        // check logs.grafana.com/drop-info annotation, if not set or set to true then drop
        // any log message with level=info
        stage.match {
          pipeline_name = "pipeline for annotation ||" + argument.annotation.value + "/drop-info: true"
          selector = "{" + argument.__sd_annotation.value + "_drop_trace=~\"" + argument.info_value.value + "\"" + ",level=~\"" + argument.info_level.value + "\"}"
          action = "drop"
          drop_counter_reason = "info"
        }

      }
    }


    declare "embed_pod" {
      argument "forward_to" {
        comment = "Must be a list(LogsReceiver) where collected logs should be forwarded to"
      }

      argument "annotation" {
        comment = "The annotation namespace to use (default: logs.grafana.com)"
        default = "logs.grafana.com"
        optional = true
      }

      argument "embed_pod_value" {
        comment = "The regular expression to use to determine if pod should be embedded or not, if you want to embed the pod by default without setting the annotations everywhere use '.*' or 'true|' (default: true)"
        default = "true"
        optional = true
      }

      argument "embed_pod_key" {
        comment = "The key to use to embed the pod name into the log message (default: __pod)"
        default = "__pod"
        optional = true
      }

      argument "__sd_annotation" {
        optional = true
        comment = "The logic is used to transform the annotation argument into a valid label name by removing unsupported characters."
        default = replace(replace(replace(coalesce(argument.annotation.value, "logs.grafana.com"),".", "_"),"/", "_"),"-", "_")
      }

      export "annotation" {
        value = argument.annotation.value
      }

      export "receiver" {
        value = loki.process.embed_pod.receiver
      }

      loki.process "embed_pod" {
        forward_to = argument.forward_to.value

        stage.match {
          selector = "{" + argument.__sd_annotation.value + "_embed_pod=~\"(?i)true\"}"
          pipeline_name = "pipeline for annotation || " + argument.annotation.value + "/embed-pod: true"

          // embed as json property
          stage.match {
            selector = "{" + argument.__sd_annotation.value + "_embed_pod=~\"(?i)true\"} |~ \"^\\s*{(.|\n)+}\\s*$\""
            // render a new label called log_line, and add the name of the pod to the end of the log message
            // knowing the pod name can be valuable for debugging, but it should not be a label in Loki due
            // to the high cardinality it would create.
            // note: .Entry is a special key that is used to reference the current line
            stage.replace {
              expression = "\\}$"
              replace = ""
            }
            stage.template {
              source = "log_line"
              template = "{{ .Entry }},\"" + argument.embed_pod_key.value + "\":\"{{ .pod }}\"}"
            }
          }

          // embed as text property
          stage.match {
            selector = "{" + argument.__sd_annotation.value + "_embed_pod=~\"(?i)true\"} !~ \"^\\s*{(.|\n)+}\\s*$\""
            // render a new label called log_line, and add the name of the pod to the end of the log message
            // knowing the pod name can be valuable for debugging, but it should not be a label in Loki due
            // to the high cardinality it would create.
            // note: .Entry is a special key that is used to reference the current line
            stage.template {
              source = "log_line"
              template = "{{ .Entry }} " + argument.embed_pod_key.value + "={{ .pod }}"
            }
          }

          // reset the output to the log_line
          stage.output {
            source = "log_line"
          }
        }
      }
    }


    declare "json_scrub_empties" {
      argument "forward_to" {
        comment = "Must be a list(LogsReceiver) where collected logs should be forwarded to"
      }

      argument "annotation" {
        comment = "The annotation namespace to use (default: logs.grafana.com)"
        default = "logs.grafana.com"
        optional = true
      }

      argument "scrub_empties_value" {
        comment = "The regular expression to use to determine if logs should have json empties scrubbed, if you want to scrub empties by default without setting the annotations everywhere use '.*' or 'true|' (default: true)"
        default = "(?i)true"
        optional = true
      }

      argument "__sd_annotation" {
        optional = true
        comment = "The logic is used to transform the annotation argument into a valid label name by removing unsupported characters."
        default = replace(replace(replace(coalesce(argument.annotation.value, "logs.grafana.com"),".", "_"),"/", "_"),"-", "_")
      }

      export "annotation" {
        value = argument.annotation.value
      }

      export "receiver" {
        value = loki.process.json_scrub_empties.receiver
      }

      loki.process "json_scrub_empties" {
        forward_to = argument.forward_to.value

        stage.match {
          pipeline_name = "pipeline for annotation || " + argument.annotation.value + "/scrub-empties: true"
          selector = "{" + argument.__sd_annotation.value + "_scrub_empties=~\"" + argument.scrub_empties_value.value + "\"} |~ \"^\\s*{(.|\n)+}\\s*$\""

          stage.replace {
            // unescaped regex: (\s*,\s*("[^"]+"\s*:\s*(\[\s*\]|\{\s*\}|"\s*"))|("[^"]+"\s*:\s*(\[\s*\]|\{\s*\}|"\s*"))\s*,\s*)
            expression = "(\\s*,\\s*(\"[^\"]+\"\\s*:\\s*(\\[\\s*\\]|\\{\\s*\\}|\"\\s*\"))|(\"[^\"]+\"\\s*:\\s*(\\[\\s*\\]|\\{\\s*\\}|\"\\s*\"))\\s*,\\s*)"
            replace = ""
          }
        }

      }
    }


    declare "json_scrub_nulls" {
      argument "forward_to" {
        comment = "Must be a list(LogsReceiver) where collected logs should be forwarded to"
      }

      argument "annotation" {
        // Docs: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
        // k8s selectors do not support a logical OR, if multiple types of annotations are needed, This component should be invoked multiple times
        // i.e. metrics.grafana.com, then again for prometheus.io
        comment = "The annotation namespace to use (default: logs.grafana.com)"
        default = "logs.grafana.com"
        optional = true
      }

      argument "scrub_nulls_value" {
        comment = "The regular expression to use to determine if logs should have json nulls scrubbed, if you want to scrub nulls by default without setting the annotations everywhere use '.*' or 'true|' (default: true)"
        default = "(?i)true"
        optional = true
      }

      argument "__sd_annotation" {
        optional = true
        comment = "The logic is used to transform the annotation argument into a valid label name by removing unsupported characters."
        default = replace(replace(replace(coalesce(argument.annotation.value, "logs.grafana.com"),".", "_"),"/", "_"),"-", "_")
      }

      export "annotation" {
        value = argument.annotation.value
      }

      export "receiver" {
        value = loki.process.json_scrub_empties.receiver
      }

      loki.process "json_scrub_nulls" {
        forward_to = argument.forward_to.value

        stage.match {
          pipeline_name = "pipeline for annotation || " + argument.annotation.value + "/scrub-nulls: true"
          selector = "{" + argument.__sd_annotation.value + "_scrub_nulls=~\"" + argument.scrub_nulls_value.value + "\"} |~ \"^\\s*{(.|\n)+}\\s*$\""

          // remove null properties
          stage.replace {
            expression = "(\\s*,\\s*(\"[^\"]+\"\\s*:\\s*null)|(\"[^\"]+\"\\s*:\\s*null)\\s*,\\s*)"
            replace = ""
          }
        }

      }
    }


    declare "pods" {
      // arguments for kubernetes discovery
      argument "namespaces" {
        comment = "The namespaces to look for targets in (default: [\"kube-system\"] is all namespaces)"
        optional = true
      }

      argument "field_selectors" {
        comment = "The label selectors to use to find matching targets (default: [])"
        optional = true
      }

      argument "label_selectors" {
        comment = "The label selectors to use to find matching targets (default: [\"k8s-app=konnectivity-agent\"])"
        optional = true
      }

      argument "annotation" {
        comment = "The annotation namespace to use (default: metrics.grafana.com)"
        default = "logs.grafana.com"
        optional = true
      }

      argument "tenant" {
        comment = "The tenant to write metrics to.  This does not have to be the tenantId, this is the value to look for in the logs.agent.grafana.com/tenant annotation, and this can be a regex."
        optional = true
        default = ".*"
      }

      argument "__sd_annotation" {
        optional = true
        comment = "The logic is used to transform the annotation argument into a valid label name by removing unsupported characters."
        default = replace(replace(replace(coalesce(argument.annotation.value, "logs.grafana.com"),".", "_"),"/", "_"),"-", "_")
      }

      export "output" {
        value = discovery.relabel.log_annotations.output
      }

      export "annotation" {
        value = coalesce(argument.annotation.value, "logs.grafana.com")
      }

      discovery.kubernetes "log_annotations" {
        role = "pod"

        selectors {
          role = "pod"
          field = join(coalesce(argument.field_selectors.value, []), ",")
          label = join(coalesce(argument.label_selectors.value, []), ",")
        }

        namespaces {
          names = coalesce(argument.namespaces.value, [])
        }
      }

      discovery.relabel "log_annotations" {
        targets = discovery.kubernetes.log_annotations.targets
      
        rule {
          action = "keep"
          source_labels = [
            "__meta_kubernetes_pod_annotation_" + argument.__sd_annotation.value + "_ingest",
          ]
          regex = "^(true|)$"
        }

        rule {
          action = "keep"
          source_labels = [
            "__meta_kubernetes_pod_annotation_" + argument.__sd_annotation.value + "_ingest",
          ]
          regex = "^(" + argument.tenant.value + ")$"
        }

        rule {
          action = "replace"
          source_labels = ["__meta_kubernetes_pod_node_name"]
          target_label = "instance"
        }

        rule {
          source_labels = ["__meta_kubernetes_namespace"]
          target_label  = "namespace"
        }

        rule {
          source_labels = ["__meta_kubernetes_pod_name"]
          target_label  = "pod"
        }

        rule {
          source_labels = ["__meta_kubernetes_pod_container_name"]
          target_label  = "container"
        }

        rule {
          source_labels = [
            "__meta_kubernetes_pod_controller_kind",
            "__meta_kubernetes_pod_controller_name",
          ]
          separator = "/"
          target_label  = "workload"
        }
        rule {
          source_labels = ["workload"]
          regex = "(ReplicaSet/.+)-.+"
          target_label  = "workload"
        }

        rule {
          action = "replace"
          source_labels = [
            "__meta_kubernetes_pod_label_app_kubernetes_io_name",
            "__meta_kubernetes_pod_label_k8s_app",
            "__meta_kubernetes_pod_label_app",
          ]
          separator = ";"
          regex = "^(?:;*)?([^;]+).*$"
          replacement = "$1"
          target_label = "app"
        }

        rule {
          action = "replace"
          source_labels = [
            "__meta_kubernetes_pod_label_app_kubernetes_io_component",
            "__meta_kubernetes_pod_label_k8s_component",
            "__meta_kubernetes_pod_label_component",
          ]
          regex = "^(?:;*)?([^;]+).*$"
          replacement = "$1"
          target_label = "component"
        }

        rule {
          action = "replace"
          source_labels = [
            "__meta_kubernetes_pod_label_app_kubernetes_io_version",
            "__meta_kubernetes_pod_label_version",
            "__meta_kubernetes_pod_label_app_version",
          ]
          regex = "^(?:;*)?([^;]+).*$"
          replacement = "$1"
          target_label = "version"
        }

        rule {
          action = "replace"
          replacement = "kubernetes"
          target_label = "source"
        }

        rule {
          action = "replace"
          source_labels = [
            "workload",
            "__meta_kubernetes_namespace",
          ]
          regex = ".+\\/(.+);(.+)"
          replacement = "$2/$1"
          target_label = "job"
        }
      }

    }     
{{- end }}   