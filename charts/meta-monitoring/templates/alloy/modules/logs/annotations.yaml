{{- if .Values.alloy.logs.enabled }}
apiVersion: v1
kind: ConfigMap
metadata:
  name: annotations
  namespace: {{ .Release.Namespace }}
data:
  annotations: |
    declare "drop_levels" {
      argument "forward_to" {
        comment = "Must be a list(LogsReceiver) where collected logs should be forwarded to"
      }

      argument "annotation" {
        // Docs: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
        // k8s selectors do not support a logical OR, if multiple types of annotations are needed, This component should be invoked multiple times
        // i.e. metrics.grafana.com, then again for prometheus.io
        comment = "The annotation namespace to use (default: logs.grafana.com)"
        default = "logs.grafana.com"
        optional = true
      }

      argument "trace_value" {
        comment = "The regular expression to use to determine if trace logs should be dropped, if you want to drop trace by default without setting the annotations everywhere use '.*' or 'true|' (default: true)"
        default = "true"
        optional = true
      }

      argument "trace_level" {
        comment = "The regular expression to use to match trace logs level label value (default: (?i)(trace?|trc))"
        default = "(?i)(trace?|trc)"
        optional = true
      }

      argument "debug_value" {
        comment = "The regular expression to use to determine if debug logs should be dropped, if you want to drop debug by default without setting the annotations everywhere use '.*' or 'true|' (default: true)"
        default = "true"
        optional = true
      }

      argument "debug_level" {
        comment = "The regular expression to use to match debug logs level label value (default: (?i)(debug?|dbg))"
        default = "(?i)(debug?|dbg)"
        optional = true
      }

      argument "info_value" {
        comment = "The regular expression to use to determine if info logs should be dropped, if you want to drop info by default without setting the annotations everywhere use '.*' or 'true|' (default: true)"
        default = "true"
        optional = true
      }

      argument "info_level" {
        comment = "The regular expression to use to match info logs level label value (default: (?i)(info?))"
        default = "(?i)(info?)"
        optional = true
      }

      /*
        Hidden Arguments
        These arguments are used to set reusable variables to avoid repeating logic
      */
      argument "__sd_annotation" {
        optional = true
        comment = "The logic is used to transform the annotation argument into a valid label name by removing unsupported characters."
        default = replace(replace(replace(coalesce(argument.annotation.value, "logs.grafana.com"),".", "_"),"/", "_"),"-", "_")
      }

      export "annotation" {
        value = argument.annotation.value
      }

      export "receiver" {
        value = loki.process.drop_level.receiver
      }

      loki.process "drop_level" {
        forward_to = argument.forward_to.value

        // check logs.grafana.com/drop-trace annotation, if not set or set to true then drop
        // any log message with level=trace
        stage.match {
          pipeline_name = "pipeline for annotation ||" + argument.annotation.value + "/drop-trace: true"
          selector = "{" + argument.__sd_annotation.value + "_drop_trace=~\"" + argument.trace_value.value + "\"" + ",level=~\"" + argument.trace_level.value + "\"}"
          action = "drop"
          drop_counter_reason = "trace"
        }

        // check logs.grafana.com/drop-debug annotation, if not set or set to true then drop
        // any log message with level=debug
        stage.match {
          pipeline_name = "pipeline for annotation ||" + argument.annotation.value + "/drop-debug: true"
          selector = "{" + argument.__sd_annotation.value + "_drop_debug=~\"" + argument.debug_value.value + "\"" + ",level=~\"" + argument.debug_level.value + "\"}"
          action = "drop"
          drop_counter_reason = "debug"
        }

        // check logs.grafana.com/drop-info annotation, if not set or set to true then drop
        // any log message with level=info
        stage.match {
          pipeline_name = "pipeline for annotation ||" + argument.annotation.value + "/drop-info: true"
          selector = "{" + argument.__sd_annotation.value + "_drop_trace=~\"" + argument.info_value.value + "\"" + ",level=~\"" + argument.info_level.value + "\"}"
          action = "drop"
          drop_counter_reason = "info"
        }

      }
    }

    declare "embed_pod" {
      argument "forward_to" {
        comment = "Must be a list(LogsReceiver) where collected logs should be forwarded to"
      }

      argument "annotation" {
        // Docs: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
        // k8s selectors do not support a logical OR, if multiple types of annotations are needed, This component should be invoked multiple times
        // i.e. metrics.grafana.com, then again for prometheus.io
        comment = "The annotation namespace to use (default: logs.grafana.com)"
        default = "logs.grafana.com"
        optional = true
      }

      argument "embed_pod_value" {
        comment = "The regular expression to use to determine if pod should be embedded or not, if you want to embed the pod by default without setting the annotations everywhere use '.*' or 'true|' (default: true)"
        default = "true"
        optional = true
      }

      argument "embed_pod_key" {
        comment = "The key to use to embed the pod name into the log message (default: __pod)"
        default = "__pod"
        optional = true
      }

      /*
        Hidden Arguments
        These arguments are used to set reusable variables to avoid repeating logic
      */
      argument "__sd_annotation" {
        optional = true
        comment = "The logic is used to transform the annotation argument into a valid label name by removing unsupported characters."
        default = replace(replace(replace(coalesce(argument.annotation.value, "logs.grafana.com"),".", "_"),"/", "_"),"-", "_")
      }

      export "annotation" {
        value = argument.annotation.value
      }

      export "receiver" {
        value = loki.process.embed_pod.receiver
      }

      loki.process "embed_pod" {
        forward_to = argument.forward_to.value

        // check logs.grafana.com/embed-pod annotation, if true embed the name of the pod to the end of the log line
        // this can reduce the overall cardinality, by not using a label of "pod", individual pods can still be searched
        // using a line selector i.e. __pod=your-pod-name
        stage.match {
          selector = "{" + argument.__sd_annotation.value + "_embed_pod=~\"(?i)true\"}"
          pipeline_name = "pipeline for annotation || " + argument.annotation.value + "/embed-pod: true"

          // embed as json property
          stage.match {
            selector = "{" + argument.__sd_annotation.value + "_embed_pod=~\"(?i)true\"} |~ \"^\\s*{(.|\n)+}\\s*$\""
            // render a new label called log_line, and add the name of the pod to the end of the log message
            // knowing the pod name can be valuable for debugging, but it should not be a label in Loki due
            // to the high cardinality it would create.
            // note: .Entry is a special key that is used to reference the current line
            stage.replace {
              expression = "\\}$"
              replace = ""
            }
            stage.template {
              source = "log_line"
              template = "{{ .Entry }},\"" + argument.embed_pod_key.value + "\":\"{{ .pod }}\"}"
            }
          }

          // embed as text property
          stage.match {
            selector = "{" + argument.__sd_annotation.value + "_embed_pod=~\"(?i)true\"} !~ \"^\\s*{(.|\n)+}\\s*$\""
            // render a new label called log_line, and add the name of the pod to the end of the log message
            // knowing the pod name can be valuable for debugging, but it should not be a label in Loki due
            // to the high cardinality it would create.
            // note: .Entry is a special key that is used to reference the current line
            stage.template {
              source = "log_line"
              template = "{{ .Entry }} " + argument.embed_pod_key.value + "={{ .pod }}"
            }
          }

          // reset the output to the log_line
          stage.output {
            source = "log_line"
          }
        }
      }
    }

    declare "json_scrub_empties" {
      argument "forward_to" {
        comment = "Must be a list(LogsReceiver) where collected logs should be forwarded to"
      }

      argument "annotation" {
        // Docs: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
        // k8s selectors do not support a logical OR, if multiple types of annotations are needed, This component should be invoked multiple times
        // i.e. metrics.grafana.com, then again for prometheus.io
        comment = "The annotation namespace to use (default: logs.grafana.com)"
        default = "logs.grafana.com"
        optional = true
      }

      argument "scrub_empties_value" {
        comment = "The regular expression to use to determine if logs should have json empties scrubbed, if you want to scrub empties by default without setting the annotations everywhere use '.*' or 'true|' (default: true)"
        default = "(?i)true"
        optional = true
      }

      /*
        Hidden Arguments
        These arguments are used to set reusable variables to avoid repeating logic
      */
      argument "__sd_annotation" {
        optional = true
        comment = "The logic is used to transform the annotation argument into a valid label name by removing unsupported characters."
        default = replace(replace(replace(coalesce(argument.annotation.value, "logs.grafana.com"),".", "_"),"/", "_"),"-", "_")
      }

      export "annotation" {
        value = argument.annotation.value
      }

      export "receiver" {
        value = loki.process.json_scrub_empties.receiver
      }

      loki.process "json_scrub_empties" {
        forward_to = argument.forward_to.value

        // check logs.grafana.com/scrub-empties annotation, if true remove any json property whose value is set to
        // an empty string "", empty object {} or empty array [] is removed
        // this can reduce the overall # of bytes sent and stored in Loki
        stage.match {
          pipeline_name = "pipeline for annotation || " + argument.annotation.value + "/scrub-empties: true"
          selector = "{" + argument.__sd_annotation.value + "_scrub_empties=~\"" + argument.scrub_empties_value.value + "\"} |~ \"^\\s*{(.|\n)+}\\s*$\""

          // remove null properties
          stage.replace {
            // unescaped regex: (\s*,\s*("[^"]+"\s*:\s*(\[\s*\]|\{\s*\}|"\s*"))|("[^"]+"\s*:\s*(\[\s*\]|\{\s*\}|"\s*"))\s*,\s*)
            expression = "(\\s*,\\s*(\"[^\"]+\"\\s*:\\s*(\\[\\s*\\]|\\{\\s*\\}|\"\\s*\"))|(\"[^\"]+\"\\s*:\\s*(\\[\\s*\\]|\\{\\s*\\}|\"\\s*\"))\\s*,\\s*)"
            replace = ""
          }
        }

      }
    }

    /*
      JSON Scrub Nulls
      This component is used to scrub nulls from JSON logs.

      Annotations:
        logs.grafana.com/scrub-nulls: true

    */
    declare "json_scrub_nulls" {
      argument "forward_to" {
        comment = "Must be a list(LogsReceiver) where collected logs should be forwarded to"
      }

      argument "annotation" {
        // Docs: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
        // k8s selectors do not support a logical OR, if multiple types of annotations are needed, This component should be invoked multiple times
        // i.e. metrics.grafana.com, then again for prometheus.io
        comment = "The annotation namespace to use (default: logs.grafana.com)"
        default = "logs.grafana.com"
        optional = true
      }

      argument "scrub_nulls_value" {
        comment = "The regular expression to use to determine if logs should have json nulls scrubbed, if you want to scrub nulls by default without setting the annotations everywhere use '.*' or 'true|' (default: true)"
        default = "(?i)true"
        optional = true
      }

      /*
        Hidden Arguments
        These arguments are used to set reusable variables to avoid repeating logic
      */
      argument "__sd_annotation" {
        optional = true
        comment = "The logic is used to transform the annotation argument into a valid label name by removing unsupported characters."
        default = replace(replace(replace(coalesce(argument.annotation.value, "logs.grafana.com"),".", "_"),"/", "_"),"-", "_")
      }

      export "annotation" {
        value = argument.annotation.value
      }

      export "receiver" {
        value = loki.process.json_scrub_empties.receiver
      }

      loki.process "json_scrub_nulls" {
        forward_to = argument.forward_to.value

        // check logs.grafana.com/scrub-empties annotation, if true remove any json property whose value is set to
        // an empty string "", empty object {} or empty array [] is removed
        // this can reduce the overall # of bytes sent and stored in Loki
        stage.match {
          pipeline_name = "pipeline for annotation || " + argument.annotation.value + "/scrub-nulls: true"
          selector = "{" + argument.__sd_annotation.value + "_scrub_nulls=~\"" + argument.scrub_nulls_value.value + "\"} |~ \"^\\s*{(.|\n)+}\\s*$\""

          // remove null properties
          stage.replace {
            // unescaped regex: (\s*,\s*("[^"]+"\s*:\s*null)|("[^"]+"\s*:\s*null)\s*,\s*)
            expression = "(\\s*,\\s*(\"[^\"]+\"\\s*:\\s*null)|(\"[^\"]+\"\\s*:\\s*null)\\s*,\\s*)"
            replace = ""
          }
        }

      }
    }

    /*
      Pods component to find eligible log targets

      Annotations:
        logs.grafana.com/ingest: true
        logs.grafana.com/tenant: "primary"
    */
    declare "pods" {
      // arguments for kubernetes discovery
      argument "namespaces" {
        comment = "The namespaces to look for targets in (default: [\"kube-system\"] is all namespaces)"
        optional = true
      }

      argument "field_selectors" {
        // Docs: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
        comment = "The label selectors to use to find matching targets (default: [])"
        optional = true
      }

      argument "label_selectors" {
        // Docs: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
        comment = "The label selectors to use to find matching targets (default: [\"k8s-app=konnectivity-agent\"])"
        optional = true
      }

      argument "annotation" {
        // Docs: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
        // k8s selectors do not support a logical OR, if multiple types of annotations are needed, this module should be invoked multiple times
        // i.e. metrics.grafana.com, then again for prometheus.io
        comment = "The annotation namespace to use (default: metrics.grafana.com)"
        default = "logs.grafana.com"
        optional = true
      }

      argument "tenant" {
        comment = "The tenant to write metrics to.  This does not have to be the tenantId, this is the value to look for in the logs.agent.grafana.com/tenant annotation, and this can be a regex."
        optional = true
        default = ".*"
      }

      /*
        Hidden Arguments
        These arguments are used to set reusable variables to avoid repeating logic
      */
      argument "__sd_annotation" {
        optional = true
        comment = "The logic is used to transform the annotation argument into a valid label name by removing unsupported characters."
        default = replace(replace(replace(coalesce(argument.annotation.value, "logs.grafana.com"),".", "_"),"/", "_"),"-", "_")
      }

      // export the discovered targets
      export "output" {
        value = discovery.relabel.log_annotations.output
      }

      // export the annotation argument
      export "annotation" {
        value = coalesce(argument.annotation.value, "logs.grafana.com")
      }

      // find all pods
      discovery.kubernetes "log_annotations" {
        role = "pod"

        selectors {
          role = "pod"
          field = join(coalesce(argument.field_selectors.value, []), ",")
          label = join(coalesce(argument.label_selectors.value, []), ",")
        }

        namespaces {
          names = coalesce(argument.namespaces.value, [])
        }
      }

      // apply relabelings
      discovery.relabel "log_annotations" {
        targets = discovery.kubernetes.log_annotations.targets

        // allow pods to declare their logs to be ingested or not, the default is true
        //   i.e. logs.grafana.com/ingest: false
        rule {
          action = "keep"
          source_labels = [
            "__meta_kubernetes_pod_annotation_" + argument.__sd_annotation.value + "_ingest",
          ]
          regex = "^(true|)$"
        }

        // allow pods to declare what tenant their logs should be written to, the following annotation is supported:
        //   logs.grafana.com/tenant: "primary"
        rule {
          action = "keep"
          source_labels = [
            "__meta_kubernetes_pod_annotation_" + argument.__sd_annotation.value + "_ingest",
          ]
          regex = "^(" + argument.tenant.value + ")$"
        }

        // set the instance label as the name of the worker node the pod is on
        rule {
          action = "replace"
          source_labels = ["__meta_kubernetes_pod_node_name"]
          target_label = "instance"
        }

        // set the namespace label
        rule {
          source_labels = ["__meta_kubernetes_namespace"]
          target_label  = "namespace"
        }

        // set the pod label
        rule {
          source_labels = ["__meta_kubernetes_pod_name"]
          target_label  = "pod"
        }

        // set the container label
        rule {
          source_labels = ["__meta_kubernetes_pod_container_name"]
          target_label  = "container"
        }

        // set a workload label
        rule {
          source_labels = [
            "__meta_kubernetes_pod_controller_kind",
            "__meta_kubernetes_pod_controller_name",
          ]
          separator = "/"
          target_label  = "workload"
        }
        // remove the hash from the ReplicaSet
        rule {
          source_labels = ["workload"]
          regex = "(ReplicaSet/.+)-.+"
          target_label  = "workload"
        }

        // set the app name if specified as metadata labels "app:" or "app.kubernetes.io/name:" or "k8s-app:"
        rule {
          action = "replace"
          source_labels = [
            "__meta_kubernetes_pod_label_app_kubernetes_io_name",
            "__meta_kubernetes_pod_label_k8s_app",
            "__meta_kubernetes_pod_label_app",
          ]
          separator = ";"
          regex = "^(?:;*)?([^;]+).*$"
          replacement = "$1"
          target_label = "app"
        }

        // set the component if specified as metadata labels "component:" or "app.kubernetes.io/component:" or "k8s-component:"
        rule {
          action = "replace"
          source_labels = [
            "__meta_kubernetes_pod_label_app_kubernetes_io_component",
            "__meta_kubernetes_pod_label_k8s_component",
            "__meta_kubernetes_pod_label_component",
          ]
          regex = "^(?:;*)?([^;]+).*$"
          replacement = "$1"
          target_label = "component"
        }

        // set the version if specified as metadata labels "version:" or "app.kubernetes.io/version:" or "app_version:"
        rule {
          action = "replace"
          source_labels = [
            "__meta_kubernetes_pod_label_app_kubernetes_io_version",
            "__meta_kubernetes_pod_label_version",
            "__meta_kubernetes_pod_label_app_version",
          ]
          regex = "^(?:;*)?([^;]+).*$"
          replacement = "$1"
          target_label = "version"
        }

        // set a source label
        rule {
          action = "replace"
          replacement = "kubernetes"
          target_label = "source"
        }

        // set the job label to be namespace / friendly pod name
        rule {
          action = "replace"
          source_labels = [
            "workload",
            "__meta_kubernetes_namespace",
          ]
          regex = ".+\\/(.+);(.+)"
          replacement = "$2/$1"
          target_label = "job"
        }
      }

    }    

    declare "decolorize" {
      argument "forward_to" {
        comment = "Must be a list(LogsReceiver) where collected logs should be forwarded to"
      }

      argument "annotation" {
        // Docs: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
        // k8s selectors do not support a logical OR, if multiple types of annotations are needed, This component should be invoked multiple times
        // i.e. metrics.grafana.com, then again for prometheus.io
        comment = "The annotation namespace to use (default: logs.grafana.com)"
        default = "logs.grafana.com"
        optional = true
      }

      argument "decolorize_value" {
        comment = "The regular expression to use to determine if logs should be decolorized, if you want to decolorize by default without setting the annotations everywhere use '.*' or 'true|' (default: true)"
        default = "(?i)true"
        optional = true
      }

      /*
        Hidden Arguments
        These arguments are used to set reusable variables to avoid repeating logic
      */
      argument "__sd_annotation" {
        optional = true
        comment = "The logic is used to transform the annotation argument into a valid label name by removing unsupported characters."
        default = replace(replace(replace(coalesce(argument.annotation.value, "logs.grafana.com"),".", "_"),"/", "_"),"-", "_")
      }

      export "annotation" {
        value = argument.annotation.value
      }

      export "receiver" {
        value = loki.process.decolorize.receiver
      }

      loki.process "decolorize" {
        forward_to = argument.forward_to.value

        // check logs.grafana.com/drop-trace annotation, if not set or set to true then drop
        // any log message with level=trace
        stage.match {
          selector = "{" + argument.__sd_annotation.value + "_decolorize=~\"" + argument.decolorize_value.value + "\"}"

          stage.decolorize {}
        }

      }
    }

    /*
      Trim
      This component is used to trim leading and trailing whitespace from log lines.

      Annotations:
        logs.grafana.com/trim: true
    */
    declare "trim" {
      argument "forward_to" {
        comment = "Must be a list(LogsReceiver) where collected logs should be forwarded to"
      }

      argument "annotation" {
        // Docs: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
        // k8s selectors do not support a logical OR, if multiple types of annotations are needed, This component should be invoked multiple times
        // i.e. metrics.grafana.com, then again for prometheus.io
        comment = "The annotation namespace to use (default: logs.grafana.com)"
        default = "logs.grafana.com"
        optional = true
      }

      argument "trim_value" {
        comment = "The regular expression to use to determine if whitespace should be embedded or not, if you want to embed the pod by default without setting the annotations everywhere use '.*' or 'true|' (default: true)"
        default = "true"
        optional = true
      }

      /*
        Hidden Arguments
        These arguments are used to set reusable variables to avoid repeating logic
      */
      argument "__sd_annotation" {
        optional = true
        comment = "The logic is used to transform the annotation argument into a valid label name by removing unsupported characters."
        default = replace(replace(replace(coalesce(argument.annotation.value, "logs.grafana.com"),".", "_"),"/", "_"),"-", "_")
      }

      export "annotation" {
        value = argument.annotation.value
      }

      export "receiver" {
        value = loki.process.trim.receiver
      }

      loki.process "trim" {
        forward_to = argument.forward_to.value

        // check logs.grafana.com/trim annotation, if true trim any leading/trailing whitespace log line
        stage.match {
          selector = "{" + argument.__sd_annotation.value + "_trim=~\"" + argument.trim_value.value + "\"}"
          pipeline_name = "pipeline for annotation || " + argument.annotation.value + "/trim: true"

          stage.template {
            source = "trimmed_line"
            template = "{{ Trim .Entry }}"
          }

          stage.output {
            source = "trimmed_line"
          }
        }
      }
    }

    /*
      Dedup Spaces
      This component is used to deduplicate spaces in log lines.

      Annotations:
        logs.grafana.com/dedup-spaces: true
    */
    declare "dedup_spaces" {
      argument "forward_to" {
        comment = "Must be a list(LogsReceiver) where collected logs should be forwarded to"
      }

      argument "annotation" {
        // Docs: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
        // k8s selectors do not support a logical OR, if multiple types of annotations are needed, This component should be invoked multiple times
        // i.e. metrics.grafana.com, then again for prometheus.io
        comment = "The annotation namespace to use (default: logs.grafana.com)"
        default = "logs.grafana.com"
        optional = true
      }

      argument "dedup_value" {
        comment = "The regular expression to use to determine if multiple spaces should be replaced with a single space or not, if you want to always dedup use '.*' or 'true|' (default: true)"
        default = "true"
        optional = true
      }

      /*
        Hidden Arguments
        These arguments are used to set reusable variables to avoid repeating logic
      */
      argument "__sd_annotation" {
        optional = true
        comment = "The logic is used to transform the annotation argument into a valid label name by removing unsupported characters."
        default = replace(replace(replace(coalesce(argument.annotation.value, "logs.grafana.com"),".", "_"),"/", "_"),"-", "_")
      }

      export "annotation" {
        value = argument.annotation.value
      }

      export "receiver" {
        value = loki.process.dedup_spaces.receiver
      }

      loki.process "dedup_spaces" {
        forward_to = argument.forward_to.value

        // check logs.grafana.com/trim annotation, if true trim any leading/trailing whitespace log line
        stage.match {
          selector = "{" + argument.__sd_annotation.value + "_dedup_spaces=~\"" + argument.dedup_value.value + "\"}"
          pipeline_name = "pipeline for annotation || " + argument.annotation.value + "/dedup-spaces: true"

          stage.replace {
            expression = "(\\s{2,})"
            replace    = " "
          }
        }
      }

    }

    /*
      Sampling
      This component is used to sample logs

      Annotations:
        logs.grafana.com/sampling: true
    */
    declare "sampling" {
      argument "forward_to" {
        comment = "Must be a list(LogsReceiver) where collected logs should be forwarded to"
      }

      argument "annotation" {
        // Docs: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
        // k8s selectors do not support a logical OR, if multiple types of annotations are needed, This component should be invoked multiple times
        // i.e. metrics.grafana.com, then again for prometheus.io
        comment = "The annotation namespace to use (default: logs.grafana.com)"
        default = "logs.grafana.com"
        optional = true
      }

      argument "sampling_value" {
        comment = "The regular expression to use to determine if the log should be sampled or not, if you want to sample the pod by default without setting the annotations everywhere use '.*' or 'true|' (default: true)"
        default = "true"
        optional = true
      }

      argument "sampling_rate" {
        comment = "The sampling rate in a range of [0, 1] (default: 0.25)"
        optional = true
        default = 0.25
      }

      argument "sampling_reason" {
        comment = "The sampling reason (default: annotation_sampling)"
        optional = true
        default = "annotation_sampling"
      }

      /*
        Hidden Arguments
        These arguments are used to set reusable variables to avoid repeating logic
      */
      argument "__sd_annotation" {
        optional = true
        comment = "The logic is used to transform the annotation argument into a valid label name by removing unsupported characters."
        default = replace(replace(replace(coalesce(argument.annotation.value, "logs.grafana.com"),".", "_"),"/", "_"),"-", "_")
      }

      export "annotation" {
        value = argument.annotation.value
      }

      export "receiver" {
        value = loki.process.sampling.receiver
      }

      loki.process "sampling" {
        forward_to = argument.forward_to.value

        // check logs.grafana.com/sampling annotation, if true the logs will be sampled at the specified rate
        stage.match {
          selector = "{" + argument.__sd_annotation.value + "_sampling=~\"" + argument.sampling_value.value + "\"}"
          pipeline_name = "pipeline for annotation || " + argument.annotation.value + "/sampling: true"

          stage.sampling {
            rate = argument.sampling_rate.value
            drop_counter_reason = argument.sampling_reason.value
          }
        }
      }

    }    
{{- end }}   